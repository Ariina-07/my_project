Ответы на вопросы для самоконтроля

1.В чем разница между временной сложностью O(n) и O(n²)?
   - O(n): время выполнения растет линейно с размером входных данных
   - O(n²): время выполнения растет квадратично (в 100 раз медленнее при n=10)

2.Как работает алгоритм бинарного поиска?
   - Работает только с отсортированными массивами
   - На каждом шаге делит область поиска пополам
   - Сложность O(log n), т.к. на каждом шаге количество элементов уменьшается вдвое

3.Преимущества и недостатки пузырьковой сортировки:
   - Преимущества: простая реализация, стабильная
   - Недостатки: медленная O(n²), неэффективна для больших массивов

4.Оптимизация проверки простого числа:
   - Проверять делимость только до √n
   - Исключить четные числа после проверки 2
   - Использовать решето Эратосфена для множественной проверки

5.Рекурсивная vs итеративная реализация Фибоначчи:
   - Рекурсивная: проще читается, но O(2^n) сложность
   - Итеративная: сложнее, но O(n) сложность и меньше памяти

6.Методы отладки:
   - console.log для промежуточных значений
   - Пошаговое выполнение в DevTools
   - Тестирование граничных случаев

7.Алгоритм Евклида:
   - Основан на свойстве: НОД(a,b) = НОД(b,a mod b)
   - Эффективен из-за быстрого уменьшения чисел

8.Edge cases для массивов:
   - Пустой массив
   - Массив с одним элементом
   - Отрицательные числа
   - Очень большие числа

9.Улучшение удаления дубликатов:
   - Использовать Set для O(1) проверки наличия элемента
   - Для больших массивов предварительная сортировка

10.Принципы чистого кода:
    - Осмысленные имена переменных
    - Единая ответственность функций
    - Комментарии для сложных алгоритмов
    - Отсутствие дублирования кода